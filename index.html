<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Terraformer Mars — Three.js (solo)</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #0b0b0b;
				color: #eee;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
					Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji",
					"Segoe UI Emoji";
			}
			#game {
				position: fixed;
				inset: 0;
			}
			canvas {
				display: block;
			}

			/* UI overlay */
			.hud {
				position: fixed;
				left: 12px;
				top: 12px;
				z-index: 10;
				display: grid;
				gap: 8px;
			}
			.panel {
				background: rgba(20, 20, 24, 0.7);
				backdrop-filter: blur(4px);
				border: 1px solid rgba(255, 255, 255, 0.08);
				border-radius: 12px;
				padding: 10px 12px;
				box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
			}
			.row {
				display: flex;
				gap: 8px;
				align-items: center;
				flex-wrap: wrap;
			}
			.stats {
				font-variant-numeric: tabular-nums;
				line-height: 1.3;
			}
			.stats b {
				color: #fff;
			}
			.btn {
				cursor: pointer;
				border: 1px solid rgba(255, 255, 255, 0.12);
				background: linear-gradient(
					180deg,
					rgba(255, 255, 255, 0.08),
					rgba(0, 0, 0, 0.2)
				);
				color: #eee;
				padding: 6px 10px;
				border-radius: 10px;
				user-select: none;
				transition: 120ms transform, 120ms background, 120ms border-color;
				font-weight: 600;
			}
			.btn:hover {
				transform: translateY(-1px);
				border-color: rgba(255, 255, 255, 0.25);
			}
			.btn:active {
				transform: translateY(0);
			}
			.btn.primary {
				background: linear-gradient(
					180deg,
					rgba(255, 140, 0, 0.45),
					rgba(255, 140, 0, 0.2)
				);
				border-color: rgba(255, 140, 0, 0.5);
				color: #fff;
			}
			.btn.ghost {
				background: rgba(255, 255, 255, 0.06);
			}
			.btn.small {
				padding: 4px 8px;
				font-size: 13px;
			}
			.btn[disabled] {
				opacity: 0.45;
				cursor: not-allowed;
			}

			.toolbar {
				display: grid;
				gap: 6px;
				grid-auto-flow: row;
			}
			.tool {
				display: flex;
				align-items: center;
				gap: 8px;
			}
			.swatch {
				width: 14px;
				height: 14px;
				border-radius: 4px;
				background: #888;
				border: 1px solid rgba(255, 255, 255, 0.2);
			}
			.tool .name {
				font-weight: 700;
			}
			.tool .desc {
				font-size: 12px;
				opacity: 0.8;
			}
			.tool .cost {
				font-size: 12px;
				opacity: 0.8;
			}
			.tool.sel {
				outline: 2px solid rgba(255, 140, 0, 0.9);
				border-radius: 10px;
				padding: 4px;
			}

			.footer {
				position: fixed;
				right: 12px;
				bottom: 12px;
				z-index: 10;
				display: grid;
				gap: 8px;
			}

			.toast {
				position: fixed;
				left: 50%;
				transform: translateX(-50%);
				bottom: 16px;
				background: rgba(10, 10, 14, 0.85);
				border: 1px solid rgba(255, 255, 255, 0.08);
				color: #fff;
				padding: 10px 14px;
				border-radius: 10px;
				z-index: 10;
				display: none;
			}

			.help {
				position: fixed;
				inset: 0;
				background: rgba(0, 0, 0, 0.55);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 20;
			}
			.help .card {
				max-width: 720px;
				margin: 24px;
				background: #121219;
				color: #eee;
				border: 1px solid rgba(255, 255, 255, 0.1);
				border-radius: 16px;
				padding: 16px 18px;
				box-shadow: 0 24px 64px rgba(0, 0, 0, 0.45);
			}
			.help h2 {
				margin: 0 0 8px 0;
			}
			.help ul {
				margin: 8px 0 0 18px;
			}
			.kbd {
				display: inline-block;
				padding: 2px 6px;
				border: 1px solid rgba(255, 255, 255, 0.2);
				border-bottom-width: 2px;
				border-radius: 6px;
				background: rgba(255, 255, 255, 0.06);
				font-weight: 700;
			}

			/* Placement ghost tooltip */
			.cursorLabel {
				position: fixed;
				z-index: 9;
				background: rgba(20, 20, 24, 0.85);
				border: 1px solid rgba(255, 255, 255, 0.12);
				color: #fff;
				border-radius: 8px;
				padding: 4px 8px;
				font-size: 12px;
				transform: translate(-50%, -160%);
				pointer-events: none;
				display: none;
			}

			a {
				color: #ffd18a;
			}
		</style>
	</head>
	<body>
		<div id="game"></div>

		<!-- HUD -->
		<div class="hud">
			<div class="panel stats" id="stats"></div>
			<div class="panel toolbar" id="toolbar"></div>
		</div>

		<div class="footer">
			<div class="panel row">
				<button class="btn small" id="btnSpeed1">Vitesse x1</button>
				<button class="btn small" id="btnSpeed3">x3</button>
				<button class="btn small" id="btnSpeed10">x10</button>
				<button class="btn small ghost" id="btnSave">Sauver</button>
				<button class="btn small ghost" id="btnLoad">Charger</button>
				<button class="btn small" id="btnReset">Réinitialiser</button>
				<button class="btn small" id="btnHelp">Aide</button>
			</div>
		</div>

		<div class="toast" id="toast"></div>

		<div class="cursorLabel" id="cursorLabel"></div>

		<div class="help" id="help">
			<div class="card">
				<h2>Terraformer Mars — Aide rapide</h2>
				<p
					>Jeu solo en 3D. Placez des installations pour produire de
					l'énergie et transformer l'atmosphère, l'eau et la température de
					Mars jusqu'à atteindre des valeurs habitables.</p
				>
				<ul>
					<li
						><b>Caméra :</b> <span class="kbd">clic gauche</span> pour
						orbiter, <span class="kbd">molette</span> pour zoom,
						<span class="kbd">clic droit</span> pour déplacer.</li
					>
					<li
						><b>Placement :</b> choisissez un bâtiment dans la barre
						d'outils, visez le sol et
						<span class="kbd">clic gauche</span> pour placer. Rouge =
						pente trop forte ou ressources insuffisantes.</li
					>
					<li
						><b>Objectif :</b> Atteindre <b>T ≥ 0°C</b>, <b>O₂ ≥ 15%</b>,
						<b>Pression ≥ 0,30 bar</b>, <b>Eau ≥ 0,50</b>.</li
					>
					<li
						><b>Conseil :</b> Commencez par l'<b>Énergie</b> (Solaire),
						puis <b>Extraction</b> (Matériaux/eau), ensuite
						<b>Atmosphère</b> et <b>Serres</b>.</li
					>
					<li
						><b>Sauvegarde :</b> boutons « Sauver/Charger »
						(localStorage).</li
					>
				</ul>
				<div class="row" style="margin-top: 10px"
					><button class="btn" id="closeHelp">Fermer</button></div
				>
			</div>
		</div>
		<!-- Three.js via import map -->
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.158.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			// --- Utilitaires -----------------------------------------------------------
			const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
			const lerp = (a, b, t) => a + (b - a) * t;
			const mix = (c1, c2, t) => c1.clone().lerp(c2, t);
			const fmt = (n, d = 2) => Number(n).toFixed(d);

			function showToast(msg, ms = 1600) {
				const el = document.getElementById("toast");
				el.textContent = msg;
				el.style.display = "block";
				clearTimeout(showToast._t);
				showToast._t = setTimeout(() => (el.style.display = "none"), ms);
			}

			// --- État du jeu -----------------------------------------------------------
			const state = {
				time: 0,
				speed: 1,
				energy: 0,
				materials: 120,
				temp: -60.0, // °C
				oxygen: 0.1, // % volumique
				pressure: 0.006, // bar (Mars ~0,006 bar)
				water: 0.0, // 0..1 (océans)
				win: false,
			};

			// Types de bâtiments
			const BUILDINGS = {
				solar: {
					name: "Champ Solaire",
					color: 0xffc107,
					size: 5,
					cost: { mat: 20 },
					consume: { energy: 0, water: 0 },
					tick(b, dt, env) {
						// production dépend de l'ensoleillement
						const sunFactor = Math.max(0, env.sunDot); // 0..1
						env.energy += 10 * sunFactor * dt; // ~10 u/s au zénith
					},
					geom() {
						const g = new THREE.Group();
						const base = new THREE.Mesh(
							new THREE.CylinderGeometry(0.6, 0.8, 0.6, 12),
							new THREE.MeshStandardMaterial({
								color: 0x444444,
								metalness: 0.2,
								roughness: 0.8,
							})
						);
						base.position.y = 0.3;
						g.add(base);
						const p = new THREE.Mesh(
							new THREE.BoxGeometry(4, 0.08, 3),
							new THREE.MeshStandardMaterial({
								color: 0x2244aa,
								metalness: 0.4,
								roughness: 0.3,
								emissive: 0x001122,
							})
						);
						p.position.y = 1.1;
						p.rotation.x = -0.35;
						g.add(p);
						return g;
					},
				},
				mine: {
					name: "Extracteur",
					color: 0x9e9e9e,
					size: 5,
					cost: { mat: 30 },
					consume: { energy: 1 },
					tick(b, dt, env) {
						if (env.tryConsume(1 * dt)) {
							env.materials += 2 * dt;
						}
					},
					geom() {
						const g = new THREE.Group();
						const body = new THREE.Mesh(
							new THREE.BoxGeometry(2.2, 1.4, 2.2),
							new THREE.MeshStandardMaterial({
								color: 0x777777,
								metalness: 0.1,
								roughness: 0.9,
							})
						);
						body.position.y = 0.7;
						g.add(body);
						const drill = new THREE.Mesh(
							new THREE.ConeGeometry(0.5, 2.5, 10),
							new THREE.MeshStandardMaterial({
								color: 0xaaaaaa,
								metalness: 0.2,
								roughness: 0.7,
							})
						);
						drill.position.y = -0.4;
						drill.rotation.x = Math.PI;
						g.add(drill);
						return g;
					},
				},
				processor: {
					name: "Processeur Atmos.",
					color: 0x00bcd4,
					size: 6,
					cost: { mat: 50 },
					consume: { energy: 2 },
					tick(b, dt, env) {
						if (env.tryConsume(2 * dt)) {
							env.pressure += 0.0008 * dt;
						}
					},
					geom() {
						const g = new THREE.Group();
						const tank = new THREE.Mesh(
							new THREE.CylinderGeometry(1.4, 1.4, 2.8, 20),
							new THREE.MeshStandardMaterial({
								color: 0x007a88,
								metalness: 0.2,
								roughness: 0.6,
							})
						);
						tank.position.y = 1.4;
						g.add(tank);
						const pipe = new THREE.Mesh(
							new THREE.TorusGeometry(1.2, 0.15, 12, 40),
							new THREE.MeshStandardMaterial({
								color: 0x2299aa,
								metalness: 0.3,
								roughness: 0.5,
							})
						);
						pipe.rotation.x = Math.PI / 2;
						pipe.position.y = 1.6;
						g.add(pipe);
						return g;
					},
				},
				extractor: {
					name: "Foreuse de Glace",
					color: 0x03a9f4,
					size: 6,
					cost: { mat: 60 },
					consume: { energy: 2 },
					tick(b, dt, env) {
						if (env.tryConsume(2 * dt)) {
							env.water = clamp(env.water + 0.002 * dt, 0, 1);
							env.materials += 0.5 * dt;
						}
					},
					geom() {
						const g = new THREE.Group();
						const tower = new THREE.Mesh(
							new THREE.CylinderGeometry(0.9, 0.9, 3.2, 16),
							new THREE.MeshStandardMaterial({
								color: 0x1e88e5,
								metalness: 0.2,
								roughness: 0.6,
							})
						);
						tower.position.y = 1.6;
						g.add(tower);
						const bit = new THREE.Mesh(
							new THREE.CylinderGeometry(0.25, 0.5, 1.2, 12),
							new THREE.MeshStandardMaterial({
								color: 0xbbdefb,
								metalness: 0.1,
								roughness: 0.8,
							})
						);
						bit.position.y = 0.1;
						g.add(bit);
						return g;
					},
				},
				greenhouse: {
					name: "Serre Biodôme",
					color: 0x66bb6a,
					size: 6,
					cost: { mat: 50 },
					consume: { energy: 1.5, water: 0.0001 },
					tick(b, dt, env) {
						if (env.tryConsume(1.5 * dt, 0.0001 * dt)) {
							env.oxygen = clamp(env.oxygen + 0.015 * dt, 0, 21);
							env.temp += 0.002 * dt;
						}
					},
					geom() {
						const g = new THREE.Group();
						const base = new THREE.Mesh(
							new THREE.CylinderGeometry(2.6, 2.6, 0.6, 24),
							new THREE.MeshStandardMaterial({
								color: 0x355a3a,
								metalness: 0.1,
								roughness: 0.8,
							})
						);
						base.position.y = 0.3;
						g.add(base);
						const dome = new THREE.Mesh(
							new THREE.SphereGeometry(
								2.5,
								24,
								16,
								0,
								Math.PI * 2,
								0,
								Math.PI / 2
							),
							new THREE.MeshPhysicalMaterial({
								color: 0x66bb6a,
								transparent: true,
								opacity: 0.35,
								roughness: 0.15,
								metalness: 0.0,
								transmission: 0.6,
								ior: 1.2,
							})
						);
						dome.position.y = 0.8;
						g.add(dome);
						return g;
					},
				},
				mirrors: {
					name: "Réseau de Miroirs",
					color: 0xff7043,
					size: 5,
					cost: { mat: 40 },
					consume: { energy: 0 },
					tick(b, dt, env) {
						env.temp += 0.05 * dt;
					},
					geom() {
						const g = new THREE.Group();
						const mast = new THREE.Mesh(
							new THREE.CylinderGeometry(0.3, 0.3, 2.6, 12),
							new THREE.MeshStandardMaterial({
								color: 0x8d6e63,
								roughness: 0.8,
							})
						);
						mast.position.y = 1.3;
						g.add(mast);
						const mirror = new THREE.Mesh(
							new THREE.CircleGeometry(2.2, 24),
							new THREE.MeshStandardMaterial({
								color: 0xffffff,
								metalness: 0.9,
								roughness: 0.05,
								emissive: 0x101010,
							})
						);
						mirror.position.y = 2.6;
						mirror.rotation.x = -0.5;
						g.add(mirror);
						return g;
					},
				},
			};

			// --- Scène 3D --------------------------------------------------------------
			const gameEl = document.getElementById("game");
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
			renderer.setSize(innerWidth, innerHeight);
			renderer.shadowMap.enabled = true;
			gameEl.appendChild(renderer.domElement);

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x1a0d0d);
			scene.fog = new THREE.Fog(0x4a1a1a, 60, 340);

			const camera = new THREE.PerspectiveCamera(
				60,
				innerWidth / innerHeight,
				0.1,
				1000
			);
			camera.position.set(60, 45, 90);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.06;
			controls.minDistance = 18;
			controls.maxDistance = 360;
			controls.maxPolarAngle = Math.PI * 0.49;

			// Lumières
			const ambient = new THREE.AmbientLight(0xffffff, 0.8);
			scene.add(ambient);
			const sun = new THREE.DirectionalLight(0xffffff, 1.0);
			sun.castShadow = true;
			sun.shadow.mapSize.set(1024, 1024);
			sun.shadow.camera.near = 10;
			sun.shadow.camera.far = 400;
			sun.shadow.camera.left = -100;
			sun.shadow.camera.right = 100;
			sun.shadow.camera.top = 100;
			sun.shadow.camera.bottom = -100;
			scene.add(sun);

			// --- Génération du sol (encapsulée) ---------------------------------------
			const FloorCreator = {
				SIZE: 260,
				SEG: 160,
				material: new THREE.MeshStandardMaterial({
					color: 0x7a2d2d,
					roughness: 1.0,
					metalness: 0.0,
				}),
				mesh: null,
				generateGeometry() {
					const g = new THREE.PlaneGeometry(
						this.SIZE,
						this.SIZE,
						this.SEG,
						this.SEG
					);
					g.rotateX(-Math.PI / 2);
					for (let i = 0; i < g.attributes.position.count; i++) {
						const x = g.attributes.position.getX(i);
						const z = g.attributes.position.getZ(i);
						const y =
							1.5 * Math.sin(x * 0.06) +
							1.2 * Math.cos(z * 0.055) +
							1.0 * Math.sin((x + z) * 0.03) +
							0.6 * Math.cos((x - z) * 0.08);
						g.attributes.position.setY(i, y);
					}
					g.computeVertexNormals();
					return g;
				},
				create(scene) {
					const geom = this.generateGeometry();
					this.mesh = new THREE.Mesh(geom, this.material);
					this.mesh.receiveShadow = true;
					scene.add(this.mesh);
					return this.mesh;
				},
				getNormalAt(worldPos, raycaster) {
					const up = new THREE.Vector3(0, 1, 0);
					const from = worldPos.clone().addScaledVector(up, 10);
					raycaster.set(from, new THREE.Vector3(0, -1, 0));
					const hit = raycaster.intersectObject(this.mesh, true)[0];
					if (hit && hit.face) {
						return hit.face.normal
							.clone()
							.transformDirection(this.mesh.matrixWorld)
							.normalize();
					}
					return up.clone();
				},
			};

			// Crée le sol + une grille d'aide
			FloorCreator.create(scene);
			const SIZE = FloorCreator.SIZE; // alias pratique
			const grid = new THREE.GridHelper(SIZE, 26, 0x553333, 0x331111);
			grid.position.y = 0.02;
			scene.add(grid);

			// Raycaster pour placement
			const ray = new THREE.Raycaster();
			const mouse = new THREE.Vector2();
			const cursorLabel = document.getElementById("cursorLabel");

			// Fantôme de placement
			const ghost = new THREE.Mesh(
				new THREE.CylinderGeometry(1, 1, 0.2, 24),
				new THREE.MeshBasicMaterial({
					color: 0x00ff88,
					transparent: true,
					opacity: 0.35,
				})
			);
			ghost.rotation.x = 0;
			ghost.visible = false;
			ghost.renderOrder = 2; // au-dessus du grid
			scene.add(ghost);

			const buildings = [];

			class Building {
				constructor(typeKey, pos) {
					this.def = BUILDINGS[typeKey];
					this.type = typeKey;
					this.group = this.def.geom();
					this.group.traverse((o) => {
						if (o.isMesh) {
							o.castShadow = true;
							o.receiveShadow = true;
						}
					});
					this.group.position.copy(pos);
					// Légère adaptation à la normale locale
					const n = getWorldNormalAt(pos);
					const q = new THREE.Quaternion().setFromUnitVectors(
						new THREE.Vector3(0, 1, 0),
						n
					);
					this.group.quaternion.slerp(q, 0.2);

					// Anneau de couleur
					const ring = new THREE.Mesh(
						new THREE.RingGeometry(
							this.def.size * 0.95,
							this.def.size,
							32
						),
						new THREE.MeshBasicMaterial({
							color: this.def.color,
							transparent: true,
							opacity: 0.35,
							side: THREE.DoubleSide,
						})
					);
					ring.rotation.x = -Math.PI / 2;
					ring.position.y = 0.02;
					this.group.add(ring);

					scene.add(this.group);
				}
				tick(dt, env) {
					this.def.tick(this, dt, env);
				}
			}

			// Fonctions d'aide consommation d'énergie/eau pour les bâtiments
			const envAPI = {
				get sunDot() {
					return Math.max(
						0,
						new THREE.Vector3()
							.copy(sun.position)
							.normalize()
							.dot(new THREE.Vector3(0, 1, 0))
					);
				},
				tryConsume(energy = 0, water = 0) {
					if (state.energy >= energy && state.water >= water) {
						state.energy -= energy;
						state.water = clamp(state.water - water, 0, 1);
						return true;
					}
					return false;
				},
				get energy() {
					return state.energy;
				},
				set energy(v) {
					state.energy = v;
				},
				get materials() {
					return state.materials;
				},
				set materials(v) {
					state.materials = v;
				},
				get temp() {
					return state.temp;
				},
				set temp(v) {
					state.temp = v;
				},
				get oxygen() {
					return state.oxygen;
				},
				set oxygen(v) {
					state.oxygen = v;
				},
				get pressure() {
					return state.pressure;
				},
				set pressure(v) {
					state.pressure = v;
				},
				get water() {
					return state.water;
				},
				set water(v) {
					state.water = v;
				},
			};

			// --- Interface -------------------------------------------------------------
			const statsEl = document.getElementById("stats");
			const toolbarEl = document.getElementById("toolbar");
			const helpEl = document.getElementById("help");

			let selected = "solar";
			function rebuildToolbar() {
				toolbarEl.innerHTML = "";
				Object.entries(BUILDINGS).forEach(([key, def]) => {
					const item = document.createElement("div");
					item.className = "tool panel";
					item.dataset.key = key;
					if (key === selected) item.classList.add("sel");
					const sw = document.createElement("div");
					sw.className = "swatch";
					sw.style.background =
						"#" + def.color.toString(16).padStart(6, "0");
					const left = document.createElement("div");
					left.innerHTML = `<div class="name">${def.name}</div><div class="desc">Taille ${def.size}m — Effets variés</div><div class="cost">Coût: <b>${def.cost.mat}</b> matériaux</div>`;
					const btn = document.createElement("button");
					btn.className = "btn small primary";
					btn.textContent = "Sélectionner";
					btn.onclick = () => {
						selected = key;
						rebuildToolbar();
						showToast(`${def.name} sélectionné`);
					};
					item.append(sw, left, btn);
					toolbarEl.appendChild(item);
				});
			}

			function updateStats() {
				statsEl.innerHTML = `
      <div><b>Énergie</b>: ${fmt(state.energy, 1)} u</div>
      <div><b>Matériaux</b>: ${fmt(state.materials, 1)}</div>
      <hr style="border-color:rgba(255,255,255,0.1); border-style:solid; border-width:1px 0 0; margin:6px 0;" />
      <div><b>Temp.</b>: ${fmt(state.temp, 1)} °C</div>
      <div><b>O₂</b>: ${fmt(state.oxygen, 2)} %</div>
      <div><b>Pression</b>: ${fmt(state.pressure, 3)} bar</div>
      <div><b>Eau</b>: ${fmt(state.water, 2)} / 1.00</div>
      <div style="opacity:.8">Bâtiments: ${buildings.length}</div>
      <div style="opacity:.8">Vitesse: x${state.speed}</div>
    `;
			}

			// Boutons vitesse & IO
			btnSpeed1.onclick = () => {
				state.speed = 1;
				showToast("Vitesse x1");
			};
			btnSpeed3.onclick = () => {
				state.speed = 3;
				showToast("Vitesse x3");
			};
			btnSpeed10.onclick = () => {
				state.speed = 10;
				showToast("Vitesse x10");
			};
			btnHelp.onclick = () => {
				helpEl.style.display = "flex";
			};
			closeHelp.onclick = () => {
				helpEl.style.display = "none";
			};
			btnSave.onclick = () => {
				saveGame();
				showToast("Sauvegarde faite");
			};
			btnLoad.onclick = () => {
				if (loadGame()) showToast("Sauvegarde chargée");
				else showToast("Aucune sauvegarde trouvée");
			};
			btnReset.onclick = () => {
				resetGame();
				showToast("Partie réinitialisée");
			};

			function saveGame() {
				const data = {
					state,
					buildings: buildings.map((b) => ({
						type: b.type,
						pos: b.group.position.toArray(),
					})),
				};
				localStorage.setItem("terraform_mars_save", JSON.stringify(data));
			}
			function loadGame() {
				const s = localStorage.getItem("terraform_mars_save");
				if (!s) return false;
				resetGame(true);
				const data = JSON.parse(s);
				Object.assign(state, data.state, { win: false });
				data.buildings.forEach((b) =>
					placeBuilding(b.type, new THREE.Vector3().fromArray(b.pos), true)
				);
				return true;
			}
			function resetGame(keepScene = false) {
				state.time = 0;
				state.speed = 1;
				state.energy = 0;
				state.materials = 120;
				state.temp = -60;
				state.oxygen = 0.1;
				state.pressure = 0.006;
				state.water = 0;
				state.win = false;
				if (!keepScene) {
					buildings.splice(0).forEach((b) => scene.remove(b.group));
				} else {
					buildings.splice(0);
				}
			}

			// --- Placement -------------------------------------------------------------
			function getIntersect(event) {
				const rect = renderer.domElement.getBoundingClientRect();
				const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
				const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
				mouse.set(x, y);
				ray.setFromCamera(mouse, camera);
				const hits = ray.intersectObject(FloorCreator.mesh);
				return hits[0] || null;
			}

			function getWorldNormalAt(pos) {
				return FloorCreator.getNormalAt(pos, ray);
			}

			function canPlaceAt(p, size) {
				const n = getWorldNormalAt(p);
				const slope = Math.acos(
					clamp(n.dot(new THREE.Vector3(0, 1, 0)), -1, 1)
				);
				const maxSlope = THREE.MathUtils.degToRad(22);
				return (
					slope < maxSlope &&
					Math.abs(p.x) < FloorCreator.SIZE * 0.48 &&
					Math.abs(p.z) < FloorCreator.SIZE * 0.48
				);
			}

			function updateGhost(event) {
				const hit = getIntersect(event);
				if (!hit) {
					ghost.visible = false;
					cursorLabel.style.display = "none";
					return;
				}
				const def = BUILDINGS[selected];
				ghost.scale.set(def.size, 1, def.size);
				ghost.position.copy(hit.point);
				ghost.visible = true;
				const ok =
					canPlaceAt(hit.point, def.size) &&
					state.materials >= def.cost.mat;
				ghost.material.color.set(ok ? 0x00ff88 : 0xff3355);
				cursorLabel.style.display = "block";
				cursorLabel.style.left = event.clientX + "px";
				cursorLabel.style.top = event.clientY + "px";
				cursorLabel.textContent =
					`${def.name} — coût ${def.cost.mat} mat.` +
					(ok ? "" : " (conditions non remplies)");
			}

			function placeBuilding(typeKey, position, loading = false) {
				const def = BUILDINGS[typeKey];
				if (!loading) {
					if (state.materials < def.cost.mat) {
						showToast("Pas assez de matériaux");
						return false;
					}
					if (!canPlaceAt(position, def.size)) {
						showToast("Pente trop forte ou hors zone");
						return false;
					}
					state.materials -= def.cost.mat;
				}
				const b = new Building(typeKey, position.clone());
				buildings.push(b);
				return true;
			}

			renderer.domElement.addEventListener("mousemove", updateGhost);
			renderer.domElement.addEventListener("mouseleave", () => {
				ghost.visible = false;
				cursorLabel.style.display = "none";
			});
			renderer.domElement.addEventListener("click", (e) => {
				const hit = getIntersect(e);
				if (!hit) return;
				placeBuilding(selected, hit.point);
			});

			// --- Boucle de jeu ---------------------------------------------------------
			let last = performance.now();
			function animate() {
				const now = performance.now();
				let dt = (now - last) / 1000;
				last = now; // en secondes
				dt = Math.min(dt, 0.1); // clamp pour éviter gros sauts

				// Cycle solaire (jour/nuit) ~ 60s
				state.time += dt * state.speed;
				const dayLen = 60; // secondes pour un cycle
				const t = (state.time % dayLen) / dayLen; // 0..1
				const angle = t * Math.PI * 2; // 0..2π
				const r = 140;
				sun.position.set(
					Math.cos(angle) * r,
					Math.sin(angle) * r * 0.8 + 40,
					Math.sin(angle) * r
				);
				sun.target?.position.set(0, 0, 0); // assure l'orientation

				// Tick bâtiments
				for (const b of buildings) {
					b.tick(dt * state.speed, envAPI);
				}

				// Inerties et bornes globales
				state.temp = clamp(state.temp, -80, 40);
				state.oxygen = clamp(state.oxygen, 0, 21);
				state.pressure = clamp(state.pressure, 0.006, 1.2);
				state.water = clamp(state.water, 0, 1);
				state.energy = Math.max(0, state.energy);

				// Victoire
				if (
					!state.win &&
					state.temp >= 0 &&
					state.oxygen >= 15 &&
					state.pressure >= 0.3 &&
					state.water >= 0.5
				) {
					state.win = true;
					showToast("✔ Mars est habitable ! Bravo");
				}

				updateVisuals();
				updateStats();

				controls.update();
				renderer.render(scene, camera);
				requestAnimationFrame(animate);
			}

			function updateVisuals() {
				// Couleur du sol évolue vers le vert/bleu avec O2/Eau/Temp
				const redMars = new THREE.Color(0x7a2d2d);
				const fertile = new THREE.Color(0x3b6e47);
				const wet = new THREE.Color(0x2e5b8a);

				const tNorm = clamp((state.temp + 60) / 75, 0, 1);
				const oNorm = clamp(state.oxygen / 21, 0, 1);
				const wNorm = clamp(state.water, 0, 1);

				const mix1 = mix(redMars, fertile, tNorm * 0.5 + oNorm * 0.5);
				const mix2 = mix(mix1, wet, wNorm * 0.4);
				FloorCreator.material.color.copy(mix2);

				const fogMars = new THREE.Color(0x4a1a1a);
				const fogBlue = new THREE.Color(0x87cefa);
				scene.fog.color.copy(
					mix(fogMars, fogBlue, oNorm * 0.4 + wNorm * 0.6)
				);

				const bgMars = new THREE.Color(0x1a0d0d);
				scene.background = mix(
					bgMars,
					new THREE.Color(0x11222a),
					oNorm * 0.3 + wNorm * 0.3
				);
			}

			// Ajustements taille
			addEventListener("resize", () => {
				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(innerWidth, innerHeight);
			});

			// Init
			rebuildToolbar();
			updateStats();
			animate();

			// Auto-sauvegarde toutes les ~60s
			setInterval(() => saveGame(), 60000);
		</script>
	</body>
</html>
